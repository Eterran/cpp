<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examples - CppBacktester Documentation</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>CppBacktester</h1>
        <p>Examples</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="installation.html">Installation</a></li>
            <li><a href="usage.html">Usage Guide</a></li>
            <li><a href="api.html">API Reference</a></li>
            <li><a href="examples.html" class="active">Examples</a></li>
        </ul>
    </nav>

    <main>
        <section class="container">
            <h2>Example Strategies</h2>
            <p>
                This section provides example strategies implemented using CppBacktester.
                These examples demonstrate how to use various features of the framework.
            </p>
        </section>

        <section class="container">
            <h2>Simple Moving Average Crossover (C++)</h2>
            <p>
                This example implements a simple moving average crossover strategy in C++.
                It buys when the short-term moving average crosses above the long-term moving average,
                and sells when the short-term moving average crosses below the long-term moving average.
            </p>
            <pre><code>#include "CppBacktester.h"
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class MovingAverageCrossover : public CppBacktester::Strategy {
private:
    int shortPeriod_;
    int longPeriod_;
    std::string symbol_;
    std::vector&lt;double&gt; prices_;
    
public:
    MovingAverageCrossover(int shortPeriod = 20, int longPeriod = 50, const std::string& symbol = "SPY")
        : shortPeriod_(shortPeriod), longPeriod_(longPeriod), symbol_(symbol) {}
    
    void initialize() override {
        std::cout << "Initializing MovingAverageCrossover strategy..." << std::endl;
        std::cout << "Short period: " << shortPeriod_ << std::endl;
        std::cout << "Long period: " << longPeriod_ << std::endl;
        std::cout << "Symbol: " << symbol_ << std::endl;
    }
    
    void onBar(const CppBacktester::Bar& bar) override {
        if (bar.symbol != symbol_) {
            return;
        }
        
        // Store the closing price
        prices_.push_back(bar.close);
        
        // Wait until we have enough data
        if (prices_.size() < longPeriod_) {
            return;
        }
        
        // Calculate short-term moving average
        double shortMA = 0.0;
        for (size_t i = prices_.size() - shortPeriod_; i < prices_.size(); ++i) {
            shortMA += prices_[i];
        }
        shortMA /= shortPeriod_;
        
        // Calculate long-term moving average
        double longMA = 0.0;
        for (size_t i = prices_.size() - longPeriod_; i < prices_.size(); ++i) {
            longMA += prices_[i];
        }
        longMA /= longPeriod_;
        
        // Get current position
        auto position = getPosition(symbol_);
        
        // Trading logic
        if (shortMA > longMA && position.quantity <= 0) {
            // Buy signal
            if (position.quantity < 0) {
                buyToCover(std::abs(position.quantity), symbol_);
            }
            buy(100, symbol_);
            std::cout << "Buy signal at " << bar.timestamp << ", price: " << bar.close << std::endl;
        } else if (shortMA < longMA && position.quantity >= 0) {
            // Sell signal
            if (position.quantity > 0) {
                sell(position.quantity, symbol_);
            }
            sellShort(100, symbol_);
            std::cout << "Sell signal at " << bar.timestamp << ", price: " << bar.close << std::endl;
        }
    }
    
    void finalize() override {
        std::cout << "Finalizing MovingAverageCrossover strategy..." << std::endl;
        std::cout << "Final portfolio value: " << getPortfolioValue() << std::endl;
    }
};

int main() {
    // Create a backtester instance
    CppBacktester::Backtester backtester;
    
    // Configure the backtester
    backtester.setStartDate("2020-01-01");
    backtester.setEndDate("2020-12-31");
    backtester.setInitialCapital(100000.0);
    
    // Load data
    backtester.loadData("data/spy_daily.csv");
    
    // Create and set the strategy
    auto strategy = std::make_shared<MovingAverageCrossover>(20, 50, "SPY");
    backtester.setStrategy(strategy);
    
    // Run the backtest
    auto results = backtester.run();
    
    // Print results
    results.printSummary();
    
    return 0;
}</code></pre>
        </section>

        <section class="container">
            <h2>Simple Moving Average Crossover (Python)</h2>
            <p>
                This example implements the same moving average crossover strategy in Python.
            </p>
            <pre><code>import cppbacktester as cb
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class MovingAverageCrossover(cb.Strategy):
    def __init__(self, short_period=20, long_period=50, symbol="SPY"):
        super().__init__()
        self.short_period = short_period
        self.long_period = long_period
        self.symbol = symbol
        self.prices = []
        
    def initialize(self):
        print(f"Initializing MovingAverageCrossover strategy...")
        print(f"Short period: {self.short_period}")
        print(f"Long period: {self.long_period}")
        print(f"Symbol: {self.symbol}")
        
    def on_bar(self, bar):
        if bar.symbol != self.symbol:
            return
            
        # Store the closing price
        self.prices.append(bar.close)
        
        # Wait until we have enough data
        if len(self.prices) < self.long_period:
            return
            
        # Calculate moving averages
        prices_array = np.array(self.prices)
        short_ma = np.mean(prices_array[-self.short_period:])
        long_ma = np.mean(prices_array[-self.long_period:])
        
        # Get current position
        position = self.get_position(self.symbol)
        
        # Trading logic
        if short_ma > long_ma and position.quantity <= 0:
            # Buy signal
            if position.quantity < 0:
                self.buy_to_cover(abs(position.quantity), self.symbol)
            self.buy(100, self.symbol)
            print(f"Buy signal at {bar.timestamp}, price: {bar.close}")
        elif short_ma < long_ma and position.quantity >= 0:
            # Sell signal
            if position.quantity > 0:
                self.sell(position.quantity, self.symbol)
            self.sell_short(100, self.symbol)
            print(f"Sell signal at {bar.timestamp}, price: {bar.close}")
            
    def finalize(self):
        print("Finalizing MovingAverageCrossover strategy...")
        print(f"Final portfolio value: {self.get_portfolio_value()}")

# Load data
data = pd.read_csv("data/spy_daily.csv")

# Create a backtester instance
backtester = cb.Backtester()

# Configure the backtester
backtester.set_start_date("2020-01-01")
backtester.set_end_date("2020-12-31")
backtester.set_initial_capital(100000.0)
backtester.load_data(data)

# Create and set the strategy
strategy = MovingAverageCrossover(20, 50, "SPY")
backtester.set_strategy(strategy)

# Run the backtest
results = backtester.run()

# Print results
results.print_summary()

# Plot equity curve
plt.figure(figsize=(12, 6))
equity_df = results.to_dataframe()
equity_df['equity'].plot()
plt.title('Equity Curve')
plt.xlabel('Date')
plt.ylabel('Equity')
plt.grid(True)
plt.show()</code></pre>
        </section>

        <section class="container">
            <h2>Mean Reversion Strategy (C++)</h2>
            <p>
                This example implements a mean reversion strategy in C++.
                It buys when the price is below the lower Bollinger Band and sells when the price is above the upper Bollinger Band.
            </p>
            <pre><code>#include "CppBacktester.h"
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

class BollingerBandMeanReversion : public CppBacktester::Strategy {
private:
    int period_;
    double stdDevMultiplier_;
    std::string symbol_;
    std::vector&lt;double&gt; prices_;
    
public:
    BollingerBandMeanReversion(int period = 20, double stdDevMultiplier = 2.0, const std::string& symbol = "SPY")
        : period_(period), stdDevMultiplier_(stdDevMultiplier), symbol_(symbol) {}
    
    void initialize() override {
        std::cout << "Initializing BollingerBandMeanReversion strategy..." << std::endl;
        std::cout << "Period: " << period_ << std::endl;
        std::cout << "Standard Deviation Multiplier: " << stdDevMultiplier_ << std::endl;
        std::cout << "Symbol: " << symbol_ << std::endl;
    }
    
    void onBar(const CppBacktester::Bar& bar) override {
        if (bar.symbol != symbol_) {
            return;
        }
        
        // Store the closing price
        prices_.push_back(bar.close);
        
        // Wait until we have enough data
        if (prices_.size() < period_) {
            return;
        }
        
        // Calculate simple moving average
        double sma = 0.0;
        for (size_t i = prices_.size() - period_; i < prices_.size(); ++i) {
            sma += prices_[i];
        }
        sma /= period_;
        
        // Calculate standard deviation
        double variance = 0.0;
        for (size_t i = prices_.size() - period_; i < prices_.size(); ++i) {
            variance += std::pow(prices_[i] - sma, 2);
        }
        variance /= period_;
        double stdDev = std::sqrt(variance);
        
        // Calculate Bollinger Bands
        double upperBand = sma + stdDevMultiplier_ * stdDev;
        double lowerBand = sma - stdDevMultiplier_ * stdDev;
        
        // Get current position
        auto position = getPosition(symbol_);
        
        // Trading logic
        if (bar.close < lowerBand && position.quantity <= 0) {
            // Buy signal - price below lower band
            if (position.quantity < 0) {
                buyToCover(std::abs(position.quantity), symbol_);
            }
            buy(100, symbol_);
            std::cout << "Buy signal at " << bar.timestamp << ", price: " << bar.close << std::endl;
        } else if (bar.close > upperBand && position.quantity >= 0) {
            // Sell signal - price above upper band
            if (position.quantity > 0) {
                sell(position.quantity, symbol_);
            }
            sellShort(100, symbol_);
            std::cout << "Sell signal at " << bar.timestamp << ", price: " << bar.close << std::endl;
        }
    }
    
    void finalize() override {
        std::cout << "Finalizing BollingerBandMeanReversion strategy..." << std::endl;
        std::cout << "Final portfolio value: " << getPortfolioValue() << std::endl;
    }
};

int main() {
    // Create a backtester instance
    CppBacktester::Backtester backtester;
    
    // Configure the backtester
    backtester.setStartDate("2020-01-01");
    backtester.setEndDate("2020-12-31");
    backtester.setInitialCapital(100000.0);
    
    // Load data
    backtester.loadData("data/spy_daily.csv");
    
    // Create and set the strategy
    auto strategy = std::make_shared<BollingerBandMeanReversion>(20, 2.0, "SPY");
    backtester.setStrategy(strategy);
    
    // Run the backtest
    auto results = backtester.run();
    
    // Print results
    results.printSummary();
    
    return 0;
}</code></pre>
        </section>

        <section class="container">
            <h2>Machine Learning Strategy (Python)</h2>
            <p>
                This example demonstrates how to use an ONNX model in a Python strategy.
            </p>
            <pre><code>import cppbacktester as cb
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

class MLStrategy(cb.Strategy):
    def __init__(self, model_path, symbol="SPY", lookback=10):
        super().__init__()
        self.model_path = model_path
        self.symbol = symbol
        self.lookback = lookback
        self.prices = []
        self.features = []
        self.scaler = StandardScaler()
        
    def initialize(self):
        print(f"Initializing ML Strategy...")
        print(f"Model path: {self.model_path}")
        print(f"Symbol: {self.symbol}")
        
        # Load ONNX model
        self.model = cb.ONNXModel(self.model_path)
        print(f"Model loaded successfully")
        print(f"Input names: {self.model.get_input_names()}")
        print(f"Output names: {self.model.get_output_names()}")
        
    def on_bar(self, bar):
        if bar.symbol != self.symbol:
            return
            
        # Store the closing price
        self.prices.append(bar.close)
        
        # Wait until we have enough data
        if len(self.prices) < self.lookback + 1:
            return
            
        # Calculate features
        returns = np.diff(self.prices) / self.prices[:-1]
        
        # Wait until we have enough return data
        if len(returns) < self.lookback:
            return
            
        # Use the last 'lookback' returns as features
        features = returns[-self.lookback:]
        
        # Normalize features
        if len(self.features) < 100:  # Use first 100 samples to fit scaler
            self.features.append(features)
            if len(self.features) == 100:
                self.scaler.fit(self.features)
            return
            
        # Normalize the features
        features_normalized = self.scaler.transform([features])[0]
        
        # Prepare input for the model
        model_input = np.array(features_normalized, dtype=np.float32)
        
        # Run inference
        prediction = self.model.predict(model_input)
        
        # Get current position
        position = self.get_position(self.symbol)
        
        # Trading logic based on model prediction
        if prediction[0] > 0.6 and position.quantity <= 0:  # Strong buy signal
            if position.quantity < 0:
                self.buy_to_cover(abs(position.quantity), self.symbol)
            self.buy(100, self.symbol)
            print(f"Buy signal at {bar.timestamp}, price: {bar.close}, prediction: {prediction[0]}")
        elif prediction[0] < 0.4 and position.quantity >= 0:  # Strong sell signal
            if position.quantity > 0:
                self.sell(position.quantity, self.symbol)
            self.sell_short(100, self.symbol)
            print(f"Sell signal at {bar.timestamp}, price: {bar.close}, prediction: {prediction[0]}")
            
    def finalize(self):
        print("Finalizing ML Strategy...")
        print(f"Final portfolio value: {self.get_portfolio_value()}")

# Load data
data = pd.read_csv("data/spy_daily.csv")

# Create a backtester instance
backtester = cb.Backtester()

# Configure the backtester
backtester.set_start_date("2020-01-01")
backtester.set_end_date("2020-12-31")
backtester.set_initial_capital(100000.0)
backtester.load_data(data)

# Create and set the strategy
strategy = MLStrategy("models/market_predictor.onnx", "SPY", 10)
backtester.set_strategy(strategy)

# Run the backtest
results = backtester.run()

# Print results
results.print_summary()

# Plot equity curve
plt.figure(figsize=(12, 6))
equity_df = results.to_dataframe()
equity_df['equity'].plot()
plt.title('Equity Curve')
plt.xlabel('Date')
plt.ylabel('Equity')
plt.grid(True)
plt.show()</code></pre>
        </section>

        <section class="container">
            <h2>Multi-Asset Strategy (C++)</h2>
            <p>
                This example demonstrates how to implement a strategy that trades multiple assets.
            </p>
            <pre><code>#include "CppBacktester.h"
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

class MomentumRotation : public CppBacktester::Strategy {
private:
    int lookbackPeriod_;
    int holdingPeriod_;
    int topN_;
    std::vector&lt;std::string&gt; symbols_;
    std::map&lt;std::string, std::vector&lt;double&gt;&gt; prices_;
    int daysSinceRebalance_;
    
public:
    MomentumRotation(int lookbackPeriod = 60, int holdingPeriod = 30, int topN = 3)
        : lookbackPeriod_(lookbackPeriod), holdingPeriod_(holdingPeriod), topN_(topN), daysSinceRebalance_(0) {
        // Define the universe of assets
        symbols_ = {"SPY", "QQQ", "IWM", "EFA", "EEM", "AGG", "TLT", "GLD", "SLV", "USO"};
    }
    
    void initialize() override {
        std::cout << "Initializing MomentumRotation strategy..." << std::endl;
        std::cout << "Lookback period: " << lookbackPeriod_ << std::endl;
        std::cout << "Holding period: " << holdingPeriod_ << std::endl;
        std::cout << "Top N assets: " << topN_ << std::endl;
        
        // Initialize price vectors for each symbol
        for (const auto& symbol : symbols_) {
            prices_[symbol] = std::vector&lt;double&gt;();
        }
    }
    
    void onBar(const CppBacktester::Bar& bar) override {
        // Check if the symbol is in our universe
        if (std::find(symbols_.begin(), symbols_.end(), bar.symbol) == symbols_.end()) {
            return;
        }
        
        // Store the closing price
        prices_[bar.symbol].push_back(bar.close);
        
        // Check if we have enough data for all symbols
        bool enoughData = true;
        for (const auto& symbol : symbols_) {
            if (prices_[symbol].size() < lookbackPeriod_) {
                enoughData = false;
                break;
            }
        }
        
        if (!enoughData) {
            return;
        }
        
        // Increment days since last rebalance
        daysSinceRebalance_++;
        
        // Check if it's time to rebalance
        if (daysSinceRebalance_ >= holdingPeriod_) {
            rebalancePortfolio();
            daysSinceRebalance_ = 0;
        }
    }
    
    void rebalancePortfolio() {
        std::cout << "Rebalancing portfolio..." << std::endl;
        
        // Calculate momentum for each symbol
        std::vector&lt;std::pair&lt;std::string, double&gt;&gt; momentum;
        for (const auto& symbol : symbols_) {
            const auto& symbolPrices = prices_[symbol];
            double startPrice = symbolPrices[symbolPrices.size() - lookbackPeriod_];
            double endPrice = symbolPrices.back();
            double momentumScore = (endPrice - startPrice) / startPrice;
            momentum.push_back({symbol, momentumScore});
        }
        
        // Sort by momentum score (descending)
        std::sort(momentum.begin(), momentum.end(), 
                 [](const auto& a, const auto& b) { return a.second > b.second; });
        
        // Close all existing positions
        for (const auto& symbol : symbols_) {
            auto position = getPosition(symbol);
            if (position.quantity > 0) {
                sell(position.quantity, symbol);
                std::cout << "Closed position in " << symbol << std::endl;
            }
        }
        
        // Calculate position size
        double portfolioValue = getPortfolioValue();
        double positionSize = portfolioValue / topN_;
        
        // Buy top N assets
        for (int i = 0; i < std::min(topN_, static_cast<int>(momentum.size())); ++i) {
            const auto& [symbol, score] = momentum[i];
            double price = prices_[symbol].back();
            int shares = static_cast<int>(positionSize / price);
            
            if (shares > 0) {
                buy(shares, symbol);
                std::cout << "Bought " << shares << " shares of " << symbol 
                          << " (momentum score: " << score << ")" << std::endl;
            }
        }
    }
    
    void finalize() override {
        std::cout << "Finalizing MomentumRotation strategy..." << std::endl;
        std::cout << "Final portfolio value: " << getPortfolioValue() << std::endl;
    }
};

int main() {
    // Create a backtester instance
    CppBacktester::Backtester backtester;
    
    // Configure the backtester
    backtester.setStartDate("2018-01-01");
    backtester.setEndDate("2020-12-31");
    backtester.setInitialCapital(100000.0);
    
    // Load data for multiple assets
    backtester.loadData("data/multi_asset_daily.csv");
    
    // Create and set the strategy
    auto strategy = std::make_shared<MomentumRotation>(60, 30, 3);
    backtester.setStrategy(strategy);
    
    // Run the backtest
    auto results = backtester.run();
    
    // Print results
    results.printSummary();
    
    return 0;
}</code></pre>
        </section>
    </main>

    <footer>
        <p>&copy; 2023 CppBacktester Project. All rights reserved.</p>
    </footer>
</body>
</html>
